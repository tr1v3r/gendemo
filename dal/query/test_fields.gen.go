// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"gendemo/dal/model"
)

func newTestField(db *gorm.DB, opts ...gen.DOOption) testField {
	_testField := testField{}

	_testField.testFieldDo.UseDB(db, opts...)
	_testField.testFieldDo.UseModel(&model.TestField{})

	tableName := _testField.testFieldDo.TableName()
	_testField.ALL = field.NewAsterisk(tableName)
	_testField.TestInt = field.NewInt(tableName, "test_int")
	_testField.TestInt8 = field.NewInt8(tableName, "test_int8")
	_testField.TestInt16 = field.NewInt16(tableName, "test_int16")
	_testField.TestInt32 = field.NewInt32(tableName, "test_int32")
	_testField.TestInt64 = field.NewInt64(tableName, "test_int64")
	_testField.TestUint = field.NewUint(tableName, "test_uint")
	_testField.TestUint8 = field.NewUint8(tableName, "test_uint8")
	_testField.TestUint16 = field.NewUint16(tableName, "test_uint16")
	_testField.TestUint32 = field.NewUint32(tableName, "test_uint32")
	_testField.TestUint64 = field.NewUint64(tableName, "test_uint64")
	_testField.TestString = field.NewString(tableName, "test_string")
	_testField.TestByte = field.NewUint8(tableName, "test_byte")
	_testField.TestFloat32 = field.NewFloat32(tableName, "test_float32")
	_testField.TestFloat64 = field.NewFloat64(tableName, "test_float64")
	_testField.TestBool = field.NewTime(tableName, "test_bool")
	_testField.TestStringPoint = field.NewString(tableName, "test_string_point")
	_testField.TestIntPoint = field.NewInt(tableName, "test_int_point")

	_testField.fillFieldMap()

	return _testField
}

type testField struct {
	testFieldDo testFieldDo

	ALL             field.Asterisk
	TestInt         field.Int
	TestInt8        field.Int8
	TestInt16       field.Int16
	TestInt32       field.Int32
	TestInt64       field.Int64
	TestUint        field.Uint
	TestUint8       field.Uint8
	TestUint16      field.Uint16
	TestUint32      field.Uint32
	TestUint64      field.Uint64
	TestString      field.String
	TestByte        field.Uint8
	TestFloat32     field.Float32
	TestFloat64     field.Float64
	TestBool        field.Time
	TestStringPoint field.String
	TestIntPoint    field.Int

	fieldMap map[string]field.Expr
}

func (t testField) Table(newTableName string) *testField {
	t.testFieldDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t testField) As(alias string) *testField {
	t.testFieldDo.DO = *(t.testFieldDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *testField) updateTableName(table string) *testField {
	t.ALL = field.NewAsterisk(table)
	t.TestInt = field.NewInt(table, "test_int")
	t.TestInt8 = field.NewInt8(table, "test_int8")
	t.TestInt16 = field.NewInt16(table, "test_int16")
	t.TestInt32 = field.NewInt32(table, "test_int32")
	t.TestInt64 = field.NewInt64(table, "test_int64")
	t.TestUint = field.NewUint(table, "test_uint")
	t.TestUint8 = field.NewUint8(table, "test_uint8")
	t.TestUint16 = field.NewUint16(table, "test_uint16")
	t.TestUint32 = field.NewUint32(table, "test_uint32")
	t.TestUint64 = field.NewUint64(table, "test_uint64")
	t.TestString = field.NewString(table, "test_string")
	t.TestByte = field.NewUint8(table, "test_byte")
	t.TestFloat32 = field.NewFloat32(table, "test_float32")
	t.TestFloat64 = field.NewFloat64(table, "test_float64")
	t.TestBool = field.NewTime(table, "test_bool")
	t.TestStringPoint = field.NewString(table, "test_string_point")
	t.TestIntPoint = field.NewInt(table, "test_int_point")

	t.fillFieldMap()

	return t
}

func (t *testField) WithContext(ctx context.Context) *testFieldDo {
	return t.testFieldDo.WithContext(ctx)
}

func (t testField) TableName() string { return t.testFieldDo.TableName() }

func (t testField) Alias() string { return t.testFieldDo.Alias() }

func (t testField) Columns(cols ...field.Expr) gen.Columns { return t.testFieldDo.Columns(cols...) }

func (t *testField) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *testField) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 17)
	t.fieldMap["test_int"] = t.TestInt
	t.fieldMap["test_int8"] = t.TestInt8
	t.fieldMap["test_int16"] = t.TestInt16
	t.fieldMap["test_int32"] = t.TestInt32
	t.fieldMap["test_int64"] = t.TestInt64
	t.fieldMap["test_uint"] = t.TestUint
	t.fieldMap["test_uint8"] = t.TestUint8
	t.fieldMap["test_uint16"] = t.TestUint16
	t.fieldMap["test_uint32"] = t.TestUint32
	t.fieldMap["test_uint64"] = t.TestUint64
	t.fieldMap["test_string"] = t.TestString
	t.fieldMap["test_byte"] = t.TestByte
	t.fieldMap["test_float32"] = t.TestFloat32
	t.fieldMap["test_float64"] = t.TestFloat64
	t.fieldMap["test_bool"] = t.TestBool
	t.fieldMap["test_string_point"] = t.TestStringPoint
	t.fieldMap["test_int_point"] = t.TestIntPoint
}

func (t testField) clone(db *gorm.DB) testField {
	t.testFieldDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t testField) replaceDB(db *gorm.DB) testField {
	t.testFieldDo.ReplaceDB(db)
	return t
}

type testFieldDo struct{ gen.DO }

// Where("name=@name and age=@age")
func (t testFieldDo) FindByNameAndAge(name string, age int) (result *model.TestField, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, name)
	params = append(params, age)
	generateSQL.WriteString("name=? and age=? ")

	var executeSQL *gorm.DB
	executeSQL = t.UnderlyingDB().Where(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// sql(select id,name,age from users where age>18)
func (t testFieldDo) FindBySimpleName() (result []*model.TestField, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select id,name,age from users where age>18 ")

	var executeSQL *gorm.DB
	executeSQL = t.UnderlyingDB().Raw(generateSQL.String()).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// sql(select id,name,age from @@table where age>18
// {{if cond1}}and id=@id {{end}}
// {{if name == ""}}and @@col=@name{{end}})
func (t testFieldDo) FindByIDOrName(cond1 bool, id int, col string, name string) (result *model.TestField, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	generateSQL.WriteString("select id,name,age from test_fields where age>18 ")
	if cond1 {
		params = append(params, id)
		generateSQL.WriteString("and id=? ")
	}
	if name == "" {
		params = append(params, name)
		generateSQL.WriteString("and " + t.Quote(col) + "=? ")
	}

	var executeSQL *gorm.DB
	executeSQL = t.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// sql(select * from users)
func (t testFieldDo) FindAll() (result []map[string]interface{}, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users ")

	var executeSQL *gorm.DB
	executeSQL = t.UnderlyingDB().Raw(generateSQL.String()).Find(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

// sql(select * from users limit 1)
func (t testFieldDo) FindOne() (result map[string]interface{}) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select * from users limit 1 ")

	result = make(map[string]interface{})
	var executeSQL *gorm.DB
	executeSQL = t.UnderlyingDB().Raw(generateSQL.String()).Take(result) // ignore_security_alert
	_ = executeSQL

	return
}

// sql(select address from users limit 1)
func (t testFieldDo) FindAddress() (result model.TestField, err error) {
	var generateSQL strings.Builder
	generateSQL.WriteString("select address from users limit 1 ")

	var executeSQL *gorm.DB
	executeSQL = t.UnderlyingDB().Raw(generateSQL.String()).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (t testFieldDo) Debug() *testFieldDo {
	return t.withDO(t.DO.Debug())
}

func (t testFieldDo) WithContext(ctx context.Context) *testFieldDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t testFieldDo) ReadDB() *testFieldDo {
	return t.Clauses(dbresolver.Read)
}

func (t testFieldDo) WriteDB() *testFieldDo {
	return t.Clauses(dbresolver.Write)
}

func (t testFieldDo) Session(config *gorm.Session) *testFieldDo {
	return t.withDO(t.DO.Session(config))
}

func (t testFieldDo) Clauses(conds ...clause.Expression) *testFieldDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t testFieldDo) Returning(value interface{}, columns ...string) *testFieldDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t testFieldDo) Not(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t testFieldDo) Or(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t testFieldDo) Select(conds ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t testFieldDo) Where(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t testFieldDo) Order(conds ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t testFieldDo) Distinct(cols ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t testFieldDo) Omit(cols ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t testFieldDo) Join(table schema.Tabler, on ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t testFieldDo) LeftJoin(table schema.Tabler, on ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t testFieldDo) RightJoin(table schema.Tabler, on ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t testFieldDo) Group(cols ...field.Expr) *testFieldDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t testFieldDo) Having(conds ...gen.Condition) *testFieldDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t testFieldDo) Limit(limit int) *testFieldDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t testFieldDo) Offset(offset int) *testFieldDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t testFieldDo) Scopes(funcs ...func(gen.Dao) gen.Dao) *testFieldDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t testFieldDo) Unscoped() *testFieldDo {
	return t.withDO(t.DO.Unscoped())
}

func (t testFieldDo) Create(values ...*model.TestField) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t testFieldDo) CreateInBatches(values []*model.TestField, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t testFieldDo) Save(values ...*model.TestField) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t testFieldDo) First() (*model.TestField, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) Take() (*model.TestField, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) Last() (*model.TestField, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) Find() ([]*model.TestField, error) {
	result, err := t.DO.Find()
	return result.([]*model.TestField), err
}

func (t testFieldDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TestField, err error) {
	buf := make([]*model.TestField, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t testFieldDo) FindInBatches(result *[]*model.TestField, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t testFieldDo) Attrs(attrs ...field.AssignExpr) *testFieldDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t testFieldDo) Assign(attrs ...field.AssignExpr) *testFieldDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t testFieldDo) Joins(fields ...field.RelationField) *testFieldDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t testFieldDo) Preload(fields ...field.RelationField) *testFieldDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t testFieldDo) FirstOrInit() (*model.TestField, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) FirstOrCreate() (*model.TestField, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TestField), nil
	}
}

func (t testFieldDo) FindByPage(offset int, limit int) (result []*model.TestField, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t testFieldDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t testFieldDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t testFieldDo) Delete(models ...*model.TestField) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *testFieldDo) withDO(do gen.Dao) *testFieldDo {
	t.DO = *do.(*gen.DO)
	return t
}
